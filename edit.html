<!DOCTYPE html>
<head>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/handsontable@latest/dist/handsontable.full.min.css">
<link rel="stylesheet" type="text/css" href="https://handsontable.com/static/css/main.css">
<script src="https://cdn.jsdelivr.net/npm/handsontable@latest/dist/handsontable.full.js"></script>

<!-- <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
-->

</head>


<body>
<div id="export-buttons" class="visible"><button id="export-csv" class="btn size-medium bg-blue text-white shadow hover-moveup" style="margin-right: 5px;">Export to a .csv file</button><button id="export-string" class="btn size-medium bg-green text-white shadow hover-moveup">Export to string (see the browser console)</button></div>

<div id="hot"></div>

<script>

document.getElementById("export-csv").addEventListener("click", function(event) { hot.getPlugin("exportFile").downloadFile("csv", {filename: "Handsontable CSV Export example"});})
document.getElementById("export-string").addEventListener("click", function(event) {
// xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded")
	// console.log(document.hot.getPlugin("exportFile").exportAsString("csv"));
	// console.log(document.hot.getPlugin("exportFile").exportAsString("json"));
	console.log(document.hot.getData());
	var xhr = new XMLHttpRequest();
	xhr.open("POST", "/auto_pr/", true);
	xhr.setRequestHeader("Content-Type", "application/json")
	xhr.onreadystatechange = function() { 
	// Call a function when the state changes.
	    if (this.readyState === XMLHttpRequest.DONE){
	    	if (this.status===200){
		    	window.alert('Update successful!')
	    	}else{
		    	window.alert('Update failed!'+this)    		
	    	}
	    }
	}
	var data=document.hot.getData();
	xhr.send(JSON.stringify({
		"type":"csvBuffer",
		"data":data,
		"columns":document.hot.getColHeader(),
	}));

	// xhr.send(JSON.stringify(document.hot.getData()));
})


// var hotElement = document.querySelector('#hot');
// var hotElementContainer = hotElement.parentNode;
// var hotSettings = {};
// var hot = new Handsontable(hotElement, hotSettings);

document.addEventListener('DOMContentLoaded', function() {

	var xhttp = new XMLHttpRequest();
	xhttp.open("GET", "current.csv", true);
	xhttp.onreadystatechange = function() {
	  if (this.readyState == 4 && this.status == 200) {
		var dataBuffer = CSVToArray(this.responseText);

		document.dataBuffer = dataBuffer;
		var columns = dataBuffer[0];
		var hotSettings = {
		  data: dataBuffer.slice(1),
		  // dataObject,
		  colHeaders: columns,
		  columns: [...Array(columns.length).keys()].map(function(v){return ({data:v, width:(window.innerWidth-100)/columns.length})}),
		  stretchH: 'all',
		  width: 805,
		  autoWrapRow: true,
		  // height: "100%",
		  // maxRows: 22,
		  manualRowResize: true,
		  manualColumnResize: true,
		  rowHeaders: true,
		  // colHeaders: true,
		  manualRowMove: true,
		  manualColumnMove: true,
		  contextMenu: true,
		  filters: true,
		  dropdownMenu: true,
		  exportFile: true
		};    
		// container2 = document.getElementById('hot')
		document.hot = new Handsontable(
			document.getElementById('hot'),
			hotSettings);
	  	// console.log(this.responseText)
	    // document.getElementById("demo").innerHTML = this.responseText;
	  }else{
	  	console.log(this);
	  }
	};
	xhttp.send();

});


    // ref: http://stackoverflow.com/a/1293163/2343
    // This will parse a delimited string into an array of
    // arrays. The default delimiter is the comma, but this
    // can be overriden in the second argument.
    function CSVToArray( strData, strDelimiter ){
        // Check to see if the delimiter is defined. If not,
        // then default to comma.
        strDelimiter = (strDelimiter || ",");

        // Create a regular expression to parse the CSV values.
        var objPattern = new RegExp(
            (
                // Delimiters.
                "(\\" + strDelimiter + "|\\r?\\n|\\r|^)" +

                // Quoted fields.
                "(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|" +

                // Standard fields.
                "([^\"\\" + strDelimiter + "\\r\\n]*))"
            ),
            "gi"
            );


        // Create an array to hold our data. Give the array
        // a default empty first row.
        var arrData = [[]];

        // Create an array to hold our individual pattern
        // matching groups.
        var arrMatches = null;


        // Keep looping over the regular expression matches
        // until we can no longer find a match.
        while (arrMatches = objPattern.exec( strData )){

            // Get the delimiter that was found.
            var strMatchedDelimiter = arrMatches[ 1 ];

            // Check to see if the given delimiter has a length
            // (is not the start of string) and if it matches
            // field delimiter. If id does not, then we know    // ref: http://stackoverflow.com/a/1293163/2343
    // This will parse a delimited string into an array of
    // arrays. The default delimiter is the comma, but this
    // can be overriden in the second argument.
    function CSVToArray( strData, strDelimiter ){
        // Check to see if the delimiter is defined. If not,
        // then default to comma.
        strDelimiter = (strDelimiter || ",");

        // Create a regular expression to parse the CSV values.
        var objPattern = new RegExp(
            (
                // Delimiters.
                "(\\" + strDelimiter + "|\\r?\\n|\\r|^)" +

                // Quoted fields.
                "(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|" +

                // Standard fields.
                "([^\"\\" + strDelimiter + "\\r\\n]*))"
            ),
            "gi"
            );


        // Create an array to hold our data. Give the array
        // a default empty first row.
        var arrData = [[]];

        // Create an array to hold our individual pattern
        // matching groups.
        var arrMatches = null;


        // Keep looping over the regular expression matches
        // until we can no longer find a match.
        while (arrMatches = objPattern.exec( strData )){

            // Get the delimiter that was found.
            var strMatchedDelimiter = arrMatches[ 1 ];

            // Check to see if the given delimiter has a length
            // (is not the start of string) and if it matches
            // field delimiter. If id does not, then we know
            // that this delimiter is a row delimiter.
            if (
                strMatchedDelimiter.length &&
                strMatchedDelimiter !== strDelimiter
                ){

                // Since we have reached a new row of data,
                // add an empty row to our data array.
                arrData.push( [] );

            }

            var strMatchedValue;

            // Now that we have our delimiter out of the way,
            // let's check to see which kind of value we
            // captured (quoted or unquoted).
            if (arrMatches[ 2 ]){

                // We found a quoted value. When we capture
                // this value, unescape any double quotes.
                strMatchedValue = arrMatches[ 2 ].replace(
                    new RegExp( "\"\"", "g" ),
                    "\""
                    );

            } else {

                // We found a non-quoted value.
                strMatchedValue = arrMatches[ 3 ];

            }


            // Now that we have our value string, let's add
            // it to the data array.
            arrData[ arrData.length - 1 ].push( strMatchedValue );
        }

        // Return the parsed data.
        return( arrData );
    }
            // that this delimiter is a row delimiter.
            if (
                strMatchedDelimiter.length &&
                strMatchedDelimiter !== strDelimiter
                ){

                // Since we have reached a new row of data,
                // add an empty row to our data array.
                arrData.push( [] );

            }

            var strMatchedValue;

            // Now that we have our delimiter out of the way,
            // let's check to see which kind of value we
            // captured (quoted or unquoted).
            if (arrMatches[ 2 ]){

                // We found a quoted value. When we capture
                // this value, unescape any double quotes.
                strMatchedValue = arrMatches[ 2 ].replace(
                    new RegExp( "\"\"", "g" ),
                    "\""
                    );

            } else {

                // We found a non-quoted value.
                strMatchedValue = arrMatches[ 3 ];

            }


            // Now that we have our value string, let's add
            // it to the data array.
            arrData[ arrData.length - 1 ].push( strMatchedValue );
        }

        // Return the parsed data.
        return( arrData );
    }
</script>

</body>
</html>